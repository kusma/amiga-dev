==id $Id: exec_lib.sfd 45.2 1998/06/06 12:43:53 olsen Exp olsen $
==base _SysBase
==basetype struct ExecBase *
==libname exec.library
==bias 30
==public
==include <exec/types.h>
==include <exec/tasks.h>
==include <exec/memory.h>
==include <exec/ports.h>
==include <exec/devices.h>
==include <exec/io.h>
==include <exec/semaphores.h>
==include <exec/avl.h>
ULONG Supervisor(ULONG (*userFunction)()) (a5)
==reserve 6
VOID InitCode(ULONG startClass, ULONG version) (d0,d1)
VOID InitStruct(const APTR initTable, APTR memory, ULONG size) (a1,a2,d0)
struct Library * MakeLibrary(const APTR funcInit, const APTR structInit,
	ULONG (*libInit)(), ULONG dataSize, ULONG segList) (a0,a1,a2,d0,d1)
VOID MakeFunctions(APTR target, const APTR functionArray, const APTR funcDispBase) (a0,a1,a2)
struct Resident * FindResident(CONST_STRPTR name) (a1)
APTR InitResident(const struct Resident * resident, ULONG segList) (a1,d1)
VOID Alert(ULONG alertNum) (d7)
VOID Debug(ULONG flags) (d0)
VOID Disable() ()
VOID Enable() ()
VOID Forbid() ()
VOID Permit() ()
ULONG SetSR(ULONG newSR, ULONG mask) (d0,d1)
APTR SuperState() ()
VOID UserState(APTR sysStack) (d0)
struct Interrupt * SetIntVector(LONG intNumber, const struct Interrupt * interrupt) (d0,a1)
VOID AddIntServer(LONG intNumber, struct Interrupt * interrupt) (d0,a1)
VOID RemIntServer(LONG intNumber, struct Interrupt * interrupt) (d0,a1)
VOID Cause(struct Interrupt * interrupt) (a1)
APTR Allocate(struct MemHeader * freeList, ULONG byteSize) (a0,d0)
VOID Deallocate(struct MemHeader * freeList, APTR memoryBlock, ULONG byteSize) (a0,a1,d0)
APTR AllocMem(ULONG byteSize, ULONG requirements) (d0,d1)
APTR AllocAbs(ULONG byteSize, APTR location) (d0,a1)
VOID FreeMem(APTR memoryBlock, ULONG byteSize) (a1,d0)
ULONG AvailMem(ULONG requirements) (d1)
struct MemList * AllocEntry(struct MemList * entry) (a0)
VOID FreeEntry(struct MemList * entry) (a0)
VOID Insert(struct List * list, struct Node * node, struct Node * pred) (a0,a1,a2)
VOID AddHead(struct List * list, struct Node * node) (a0,a1)
VOID AddTail(struct List * list, struct Node * node) (a0,a1)
VOID Remove(struct Node * node) (a1)
struct Node * RemHead(struct List * list) (a0)
struct Node * RemTail(struct List * list) (a0)
VOID Enqueue(struct List * list, struct Node * node) (a0,a1)
struct Node * FindName(struct List * list, CONST_STRPTR name) (a0,a1)
APTR AddTask(struct Task * task, const APTR initPC, const APTR finalPC) (a1,a2,a3)
VOID RemTask(struct Task * task) (a1)
struct Task * FindTask(CONST_STRPTR name) (a1)
BYTE SetTaskPri(struct Task * task, LONG priority) (a1,d0)
ULONG SetSignal(ULONG newSignals, ULONG signalSet) (d0,d1)
ULONG SetExcept(ULONG newSignals, ULONG signalSet) (d0,d1)
ULONG Wait(ULONG signalSet) (d0)
VOID Signal(struct Task * task, ULONG signalSet) (a1,d0)
BYTE AllocSignal(BYTE signalNum) (d0)
VOID FreeSignal(BYTE signalNum) (d0)
LONG AllocTrap(LONG trapNum) (d0)
VOID FreeTrap(LONG trapNum) (d0)
VOID AddPort(struct MsgPort * port) (a1)
VOID RemPort(struct MsgPort * port) (a1)
VOID PutMsg(struct MsgPort * port, struct Message * message) (a0,a1)
struct Message * GetMsg(struct MsgPort * port) (a0)
VOID ReplyMsg(struct Message * message) (a1)
struct Message * WaitPort(struct MsgPort * port) (a0)
struct MsgPort * FindPort(CONST_STRPTR name) (a1)
VOID AddLibrary(struct Library * library) (a1)
VOID RemLibrary(struct Library * library) (a1)
struct Library * OldOpenLibrary(CONST_STRPTR libName) (a1)
VOID CloseLibrary(struct Library * library) (a1)
APTR SetFunction(struct Library * library, LONG funcOffset, ULONG (*newFunction)()) (a1,a0,d0)
VOID SumLibrary(struct Library * library) (a1)
VOID AddDevice(struct Device * device) (a1)
VOID RemDevice(struct Device * device) (a1)
BYTE OpenDevice(CONST_STRPTR devName, ULONG unit, struct IORequest * ioRequest,
	ULONG flags) (a0,d0,a1,d1)
VOID CloseDevice(struct IORequest * ioRequest) (a1)
BYTE DoIO(struct IORequest * ioRequest) (a1)
VOID SendIO(struct IORequest * ioRequest) (a1)
struct IORequest * CheckIO(struct IORequest * ioRequest) (a1)
BYTE WaitIO(struct IORequest * ioRequest) (a1)
VOID AbortIO(struct IORequest * ioRequest) (a1)
VOID AddResource(APTR resource) (a1)
VOID RemResource(APTR resource) (a1)
APTR OpenResource(CONST_STRPTR resName) (a1)
==reserve 3
APTR RawDoFmt(CONST_STRPTR formatString, const APTR dataStream, VOID (*putChProc)(),
	APTR putChData) (a0,a1,a2,a3)
ULONG GetCC() ()
ULONG TypeOfMem(const APTR address) (a1)
ULONG Procure(struct SignalSemaphore * sigSem, struct SemaphoreMessage * bidMsg) (a0,a1)
VOID Vacate(struct SignalSemaphore * sigSem, struct SemaphoreMessage * bidMsg) (a0,a1)
struct Library * OpenLibrary(CONST_STRPTR libName, ULONG version) (a1,d0)
==version 33
VOID InitSemaphore(struct SignalSemaphore * sigSem) (a0)
VOID ObtainSemaphore(struct SignalSemaphore * sigSem) (a0)
VOID ReleaseSemaphore(struct SignalSemaphore * sigSem) (a0)
ULONG AttemptSemaphore(struct SignalSemaphore * sigSem) (a0)
VOID ObtainSemaphoreList(struct List * sigSem) (a0)
VOID ReleaseSemaphoreList(struct List * sigSem) (a0)
struct SignalSemaphore * FindSemaphore(STRPTR name) (a1)
VOID AddSemaphore(struct SignalSemaphore * sigSem) (a1)
VOID RemSemaphore(struct SignalSemaphore * sigSem) (a1)
ULONG SumKickData() ()
VOID AddMemList(ULONG size, ULONG attributes, LONG pri, APTR base, CONST_STRPTR name) (d0,d1,d2,a0,a1)
VOID CopyMem(const APTR source, APTR dest, ULONG size) (a0,a1,d0)
VOID CopyMemQuick(const APTR source, APTR dest, ULONG size) (a0,a1,d0)
==version 36
VOID CacheClearU() ()
VOID CacheClearE(APTR address, ULONG length, ULONG caches) (a0,d0,d1)
ULONG CacheControl(ULONG cacheBits, ULONG cacheMask) (d0,d1)
APTR CreateIORequest(const struct MsgPort * port, ULONG size) (a0,d0)
VOID DeleteIORequest(APTR iorequest) (a0)
struct MsgPort * CreateMsgPort() ()
VOID DeleteMsgPort(struct MsgPort * port) (a0)
VOID ObtainSemaphoreShared(struct SignalSemaphore * sigSem) (a0)
APTR AllocVec(ULONG byteSize, ULONG requirements) (d0,d1)
VOID FreeVec(APTR memoryBlock) (a1)
APTR CreatePool(ULONG requirements, ULONG puddleSize, ULONG threshSize) (d0,d1,d2)
VOID DeletePool(APTR poolHeader) (a0)
APTR AllocPooled(APTR poolHeader, ULONG memSize) (a0,d0)
VOID FreePooled(APTR poolHeader, APTR memory, ULONG memSize) (a0,a1,d0)
ULONG AttemptSemaphoreShared(struct SignalSemaphore * sigSem) (a0)
VOID ColdReboot() ()
VOID StackSwap(struct StackSwapStruct * newStack) (a0)
==reserve 4
APTR CachePreDMA(const APTR address, ULONG * length, ULONG flags) (a0,a1,d0)
VOID CachePostDMA(const APTR address, ULONG * length, ULONG flags) (a0,a1,d0)
==version 39
VOID AddMemHandler(struct Interrupt * memhand) (a1)
VOID RemMemHandler(struct Interrupt * memhand) (a1)
ULONG ObtainQuickVector(APTR interruptCode) (a0)
==reserve 6
VOID NewMinList(struct MinList * minlist) (a0)
==reserve 3
struct AVLNode * AVL_AddNode(struct AVLNode ** root, struct AVLNode * node, APTR func) (a0,a1,a2)
struct AVLNode * AVL_RemNodeByAddress(struct AVLNode ** root, struct AVLNode * node) (a0,a1)
struct AVLNode * AVL_RemNodeByKey(struct AVLNode ** root, APTR key, APTR func) (a0,a1,a2)
struct AVLNode * AVL_FindNode(CONST struct AVLNode * root, APTR key, APTR func) (a0,a1,a2)
struct AVLNode * AVL_FindPrevNodeByAddress(CONST struct AVLNode * node) (a0)
struct AVLNode * AVL_FindPrevNodeByKey(CONST struct AVLNode * root, APTR key, APTR func) (a0,a1,a2)
struct AVLNode * AVL_FindNextNodeByAddress(CONST struct AVLNode * node) (a0)
struct AVLNode * AVL_FindNextNodeByKey(CONST struct AVLNode * root, APTR key, APTR func) (a0,a1,a2)
struct AVLNode * AVL_FindFirstNode(CONST struct AVLNode * root) (a0)
struct AVLNode * AVL_FindLastNode(CONST struct AVLNode * root) (a0)
==end
